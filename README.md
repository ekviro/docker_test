# docker_test
изучение докера

Запустить со сборкой текущего кода
```
docker-compose up -d --build
```
Запустить только готовые контейнеры docker-compose
```
docker-compose up -d --build
```
Остановить контейнеры без удаления данных БД
```
docker-compose down
```
Остановить с удалением данных (volume), потом скрипты опять выполнятся при запуске
```
docker-compose down -v
```
Запустить тесты в докере
```
docker-compose run tests
```
Посмотреть логи докера
```
docker-compose logs server -f
```



### Коротко: 
для запуска стандартных образов нужен только docker-compose.yml, который сам качает нужные образы из сети.
Для своих сборок контейнеров нужно писать Dockerfile.

Для запуска всех контейнеров из docker-compose.yml нужно  
в терминале из корневой папки
```
docker-compose up -d
```
Остановить контейнеры без удаления данных БД
```
docker-compose down
```
Остановить с удалением данных (volume), потом скрипты опять выполнятся при запуске
```
docker-compose down -v
```

Самописный сервер для api-ручек в папке server.  
Если запускать сервер и БД только в докере, то ИЗ КОРНЯ проекта БЕЗ вирт. окружения
```
docker-compose up -d --build
```
В первый раз скачает очень много  
В докер-десктопе видно, что два контейнера  
Можно дергать ручки по http://localhost:8000/users

Для локального запуска сервера нужно активировать виртуальную среду и  
установить в нее зависимости, пример для винды из корня проекта:
```
python -m venv venv
```

```
venv\Scripts\activate
```
в пути будет в скобках вирт.среда: `(venv) K:\Projects\docker_test>`
```
pip install -r requirements.txt
```

Далее в отдельном терминале (без вирт.окружения) запустить в докере только БД:
```
docker-compose up postgres -d
```

Затем в терминале с виртуальной средой `(venv) K:\Projects\docker_test>` запустить локально сервер:
```
uvicorn server.app:app --reload --port 8000
```
В терминале теперь будет лог сервера и когда надо выключить, то нажать CTRL+C  
В докер-десктопе видно, что два контейнера  
Можно также дергать ручки по http://localhost:8000/users

### Запуск всего в докере
```
docker-compose up -d --build
```
Для тестов отдельный контейнер, но не будет запущен  

Тесты можно запустить в докере явно (ту версию, что уже собрана)
```
docker-compose run tests
```
или локально, текущую версию (из вирт. окружения `(venv) K:\Projects\docker_test>` )
```
pytest tests/ -v
```

### Сваггер, прямо можно тестить
http://localhost:8000/docs

### Подробно:  

docker-compose.yml - "Оркестратор контейнеров".
Это файл конфигурации, который описывает, как запускать один или несколько контейнеров.

Использует готовый образ СУБД (скачивает image: postgres:15 из Docker Hub - реестра образов)

Если готовых контейнеров не хватает, то нужен Dockerfile
Dockerfile - это текстовый файл с инструкциями, как собрать свой контейнер, если:
- нужно создать свой кастомный образ
- нужно установить дополнительные пакеты
- нужно изменить конфигурацию базового образа
### Запуск
В терминале из корневой папки
```
docker-compose up -d
```
-d нужно для того, чтобы выполнялось в фоновом режиме, не занимая основной терминал. 
Иначе если выключить терминал, то контейнеры остановятся  

Далее при первом запуске выполнится скрипт создания и заполнения БД:  
volumes:  
- postgres_data:/var/lib/postgresql/data  # Постоянное хранилище данных БД  
Синтаксис: имя_тома:путь_в_контейнере  
Что происходит:  
postgres_data - том Docker (виртуальный диск)  
/var/lib/postgresql/data - папка внутри контейнера где PostgreSQL хранит данные    
Результат: Данные БД сохраняются между перезапусками контейнера  


- ./init-scripts:/docker-entrypoint-initdb.d  # Скрипты выполняются при ПЕРВОМ запуске  
Синтаксис: локальный_путь:путь_в_контейнере  
Что происходит:  
./init-scripts - папка на твоем компьютере  
/docker-entrypoint-initdb.d - специальная папка в контейнере PostgreSQL  
Результат: Файлы из локальной папки доступны в контейнере  

Аналогия:
Том (postgres_data) - как флешка:  
Подключаешь к контейнеру  
Данные сохраняются даже если контейнер удалить  
Локальная папка (./init-scripts) - как общая папка:  
Синхронизация между компьютером и контейнером  
Изменения в локальных файлах сразу видны в контейнере  
